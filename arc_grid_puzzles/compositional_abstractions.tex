\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{amsthm}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{textcomp}
\usepackage{newunicodechar}

\geometry{margin=1in}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10}
}

% Unicode character definitions
\newunicodechar{↔}{\ensuremath{\leftrightarrow}}
\newunicodechar{→}{\ensuremath{\rightarrow}}
\newunicodechar{−}{\ensuremath{-}}
\newunicodechar{≈}{\ensuremath{\approx}}
\newunicodechar{•}{\ensuremath{\bullet}
\newunicodechar{×}{\ensuremath{\times}}
}

% Custom commands
\newcommand{\code}[1]{\texttt{#1}}

\title{Compositional Abstractions for ARC-Style Tasks}
\author{}
\date{}

\begin{document}

\maketitle

\section{Abstract}

We study how \textbf{compositional abstractions} shrink program-search for ARC-style grid puzzles by removing symmetries \emph{before} search. We represent an abstraction as \textbf{(G + invariant)}: a concrete grid transformation $G$ together with an \textbf{invariant} that constrains which concrete worlds we consider equivalent. A task is solvable in an abstracted space if: (i) its invariants hold; and (ii) a \textbf{mapping exists} in the abstract space that transfers back to the concrete space via a simple gauge (bookkeeping) map.

Two tiny abstractions suffice to make otherwise messy tasks trivial:
\begin{itemize}
\item \textbf{A1: Palette canonicalization.} Relabel non-zero colors by decreasing frequency. This quotients out palette symmetry so rules like ``least-frequent color'' have a canonical id.
\item \textbf{A2: Canonical object order.} Sort connected components by $(area, top, left, color)$. This quotients out object-enumeration symmetry so rules like ``component index 0'' are stable---even in ties.
\end{itemize}

Empirically, composing \textbf{A1→A2} collapses the search space from thousands of programs to \textbf{two}; both are valid for the studied case, giving \textbf{near-zero search cost}.

\section{Introduction}

\textbf{ARC} tasks operate on small integer grids. Many puzzles involve selecting an object (a connected component), choosing a (target) color, and recoloring. Naively, a solver faces huge \textbf{spurious multiplicity}: many grids differ only by a permutation of color ids or by the order we enumerate objects, yet a human treats them as ``the same.''

Our goal is to \textbf{quotient symmetries away} with minimal machinery, leaving a tiny set of candidate programs that are all semantically distinct. We make three design choices:

\begin{itemize}
\item \textbf{Abstractions as $G +$ invariant.} Each abstraction applies a concrete normalization $G$ (e.g., renaming colors; sorting objects) and comes with an invariant that must hold after normalization.
\item \textbf{Mapping existence before search.} We first check that a simple family of mappings exists in the abstract space; only then do we enumerate candidate programs.
\item \textbf{Microscopic DSLs.} We intentionally use tiny search spaces to show how much the \textbf{symmetry quotient} alone reduces the burden.
\end{itemize}

\section{Running Examples (3 pairs)}

We use small grids where the target action can be stated compactly: \textbf{select a component} $\times$ \textbf{choose a color} $\times$ \textbf{recolor the component} (e.g., ``recolor the smallest component to the least-frequent non-zero color''). Examples include ties (equal-area components) and multi-color scenes so that without a canonical order, phrases like ``the smallest'' are ambiguous.

\section{Abstractions as G + Invariant}

We spell out the two building blocks and how they eliminate symmetry.


\subsection{A1: Palette canonicalization}

$\alpha_1$ canonicalizes the nonzero palette by relabeling colors to $\{1,\dots,k\}$ (background stays $0$) using a deterministic, permutation-invariant total order:
\begin{enumerate}
\item Sort colors by \emph{descending frequency} in the grid.
\item Break ties by the \emph{lexicographic first occurrence} coordinate $(r,c)$ of each color.
\item If still tied (pathological), break ties by the lexicographic order of the color's binary mask string over the grid.
\end{enumerate}
Write $C_1:X\to X$ for the relabeling map and let the gauge store the bijection between original and canonical ids, \code{meta = \{``orig\_for\_can'': \dots, ``can\_for\_orig'': \dots\}}.

\begin{itemize}
\item \textbf{Invariant.} Background $0$ is fixed; geometry is unchanged.
\item \textbf{Gauge.} A bidirectional palette map (original$\leftrightarrow$canonical) to transfer predictions back.
\item \textbf{Why.} Quotients out \textbf{palette symmetry} so descriptors like ``least-frequent color'' are well-defined.
\end{itemize}


\subsection{A2: Canonical object order (on top of A1)}

After applying A1, let $\mathcal{C}(x)$ be the set of \textbf{4-connected} non-background components. For each component $C$, define
$\mathrm{topleft}(C)=\min_{\mathrm{lex}}\{(r,c)\in C\}$ (lexicographic min of its cells) and $\mathrm{area}(C)=|C|$.
Define a total order on components by the tuple
\[
(\mathrm{area}(C),~\mathrm{topleft}_r(C),~\mathrm{topleft}_c(C),~\mathrm{color}(C)).
\]
Let $C_2$ attach the sorted-index metadata (without changing pixels). The gauge records the permutation between arbitrary ids and this canonical order.

\begin{itemize}
\item \textbf{Invariant.} Pure metadata; does not constrain geometry beyond ordering.
\item \textbf{Gauge.} A permutation mapping arbitrary component ids to canonical indices (and back).
\item \textbf{Why.} Removes \textbf{component-enumeration symmetry} so rules like ``smallest object'' are unambiguous.
\end{itemize}

\subsection{Mapping existence (search-free)}

Before enumerating programs, we check that an appropriate \textbf{mapping exists} in the abstract space. For the family we study (select-component $\times$ choose-color $\times$ recolor), existence reduces to:
\begin{enumerate}
\item \textbf{Selectors} can name at least one component under $\alpha_2$ (e.g., \code{index0}, \code{smallest}).
\item \textbf{Color rules} can name a palette element under $\alpha_1$ (e.g., \code{least\_frequent}, \code{most\_frequent}, or fixed ids after canon).
\item \textbf{Gauge transfer} (palette map + order list) can un-canonize the abstract action back to the original grid.
\end{enumerate}

If these checks pass on all training pairs, we proceed to program enumeration; otherwise, we abstain.

\section{Program Search Spaces (DSLs)}

\textbf{Code-coherent identifiers (from \code{arc\_abstraction\_dsl\_2.py}):}
\begin{itemize}
\item A1: \code{alpha1\_palette(x) -> (x\_hat, meta)} where \code{meta = \{"orig\_for\_can": ..., "can\_for\_orig": ...\}}.
\item A2: \code{alpha2\_objorder(x\_hat) -> (x\_hat, \{"order": comps\_sorted\})} with sort key $(area, top, left, color)$.
\item Color rules: \code{COLOR\_RULES = [("max\_id", sel\_color\_max\_id), ("argmin\_hist", sel\_color\_argmin\_hist)]}.
  \begin{itemize}
  \item Under A1, \textbf{both} pick a least-frequent color; when multiple colors tie, both choose the \textbf{largest canonical id}.
  \end{itemize}
\item Selectors:
  \begin{itemize}
  \item Raw/G: \code{sel\_comp\_smallest\_unstable} (hash-shuffled tie-break) \textbf{and} \code{sel\_comp\_smallest\_canonical}.
  \item A1: many variants from \code{build\_A1\_selectors()} (different tie-break keys and seeded shuffles) \textbf{plus} \code{sel\_comp\_smallest\_canonical}.
  \item A1→A2: fixed \code{("index0", lambda a: sel\_comp\_smallest\_canonical(a))}.
  \end{itemize}
\item G pre-ops: \code{build\_preops\_for\_dataset(...)} produces \code{("identity", ...)} and hundreds of \code{"perm\_*"} random palette permutations to explode the search space.
\end{itemize}

These names are what appear in the results and JSON artifacts the script writes.

We use three nested spaces, each reusing the same \textbf{action family} (select component $\times$ choose color $\times$ recolor) but differing in \emph{how many spurious variants} they contain.

\begin{itemize}
\item \textbf{G (raw).} Enumerates many selector variants (by geometry and enumeration) and many color rules that simulate palette symmetry. This intentionally inflates the candidate count.
\item \textbf{A1.} After palette canonicalization, we still allow numerous selector tie-break variants to show that removing palette symmetry alone is incomplete.
\item \textbf{A1→A2.} After canonical object ordering, the DSL collapses to \textbf{two} programs: $\{$color rule$\} \times \{$index0$\}$ (implemented as ``canonical smallest'').
\end{itemize}

Across all spaces, the mapping family is identical; only the \textbf{symmetry multiplicity} changes.


\subsection{Concrete worked examples (aligned with \code{arc\_abstraction\_dsl\_2.py})}

\subsubsection{Concrete example: A1 palette canonicalization}

Original grid (0=background; nonzero colors are 2,3,5):
\begin{lstlisting}
0 0 2 2 0 0
0 3 3 0 0 0
0 3 0 0 5 5
0 0 0 0 5 0
\end{lstlisting}

Non-zero histogram: 3→3, 5→3, 2→2.\\
A1 tie-break: first occurrence (row, col). First(3)=(1,1), First(5)=(2,4) so 3 < 5.\\
Canonical relabel: 3→1, 5→2, 2→3.

Canonicalized grid $x_{\hat{}}$ and meta:
\begin{lstlisting}
0 0 3 3 0 0
0 1 1 0 0 0
0 1 0 0 2 2
0 0 0 0 2 0
\end{lstlisting}
\code{meta.orig\_for\_can = \{1:3, 2:5, 3:2\}}

\subsubsection{Concrete example: A2 canonical object order}
Components of $x_{\hat{}}$ (area, topleft, color):
(2,(0,2),3), (2,(2,4),2), (3,(1,1),1).\\
Sorting by (area, topleft) gives \code{index0} = (2,(0,2),3).

\subsubsection{End-to-end example: A1→A2 + recolor + gauge back}

Selector: \code{sel\_comp\_smallest\_canonical($x_{\hat{}}$)} → the smallest-area component (index0).\\
Color rule (present-only least-frequent): color 3 (count 2).\\
Apply \code{recolor\_component($x_{\hat{}}$, index0, color=3)} (no-op here), then gauge back with \{1→3, 2→5, 3→2\}:
\begin{lstlisting}
0 0 2 2 0 0
0 3 3 0 0 0
0 3 0 0 5 5
0 0 0 0 5 0
\end{lstlisting}

\section{Algorithm (sketch)}

\begin{enumerate}
\item \textbf{Normalize inputs} with $\alpha_1$ then $\alpha_2$; record palette map and order list.
\item \textbf{Validate invariants} on all train pairs.
\item \textbf{Check mapping existence} in the abstract space (selectors $\times$ color rules $\times$ recolor).
\item \textbf{Enumerate candidate programs} in the chosen DSL (G, A1, or A1→A2).
\item \textbf{Evaluate} on train; keep programs consistent with all pairs.
\item \textbf{Transfer} the chosen abstract action back to each concrete grid via the gauges.
\end{enumerate}

This ordering---\textbf{validation → existence → search}---prevents wasted search when symmetry removal already makes the solution unique.

\section{Experimental Protocol}

We evaluate a single ARC-style task family with three DSLs (G, A1, A1→A2). Metrics:
\begin{itemize}
\item \code{total\_candidates} -- size of the enumerated space.
\item \code{num\_valid} -- programs consistent with all training pairs.
\item \code{avg\_tries\_to\_success} -- mean number of attempts until the first valid program is found when sampling uniformly at random.
\item \code{wall\_time\_s} -- runtime for a deterministic sweep on our simple reference implementation.
\end{itemize}

\section{Results}

\textbf{Local-run results (your updated run):}

\begin{table}[h]
\centering
\begin{tabular}{@{}lrrrr@{}}
\toprule
\textbf{Method} & \textbf{Total Candidates} & \textbf{Valid Programs} & \textbf{Avg Tries to Success} & \textbf{Wall Time (s)} \\
\midrule
G & 2404 & 441 & 5.405 & 3.884 \\
A1 & 172 & 4 & 35.573 & 0.197 \\
A1→A2 & 2 & 2 & 1.000 & 0.028 \\
\bottomrule
\end{tabular}
\caption{Experimental results comparing three DSL approaches: raw enumeration (G), palette canonicalization (A1), and composed abstractions (A1→A2).}
\label{tab:results}
\end{table}

These match the qualitative trend reported earlier (in a single-dataset summary) and sharpen the magnitude of the win from composing A1 with A2.

\subsection{Read-off improvements from the local run}

\begin{itemize}
\item \textbf{Program count shrinks:} G→A1: 2404→172 (\textbf{−92.85\%}); A1→A2: 172→2 (\textbf{−98.84\%}). Overall G→A1→A2: \textbf{−99.917\%} (2404→2).
\item \textbf{Runtime collapses:} 3.884s→0.197s (\textbf{×19.7 faster}); 0.197s→0.028s (\textbf{×7.0 faster}). Overall: \textbf{×138.7 faster} (3.884s→0.028s).
\item \textbf{Effort to first solution:} \code{avg\_tries\_to\_success} is \textbf{1.0} in A1→A2 (deterministic selection/order); in A1 it is 35.573 (sensitive to tie-break variants); composition with A2 removes that ambiguity.
\item \textbf{Validity rates:} A1→A2: \textbf{2/2 (100\%)}; A1: \textbf{4/172 (≈ 2.3\%)}; G: \textbf{441/2404 (≈ 18.3\%)}.
\end{itemize}

\section{Properties and Proof Sketches}

We record the key algebraic properties that make $C_2\!\circ C_1$ a robust quotient.

\paragraph{A1 invariance to palette relabeling.}
For any permutation $\pi$ of nonzero labels, $C_1(\pi\!\cdot\!x)=C_1(x)$. Frequencies and first-occurrence coordinates depend only on the \emph{support} of each color, not its id.

\paragraph{A1 idempotence.}
$C_1(C_1(x))=C_1(x)$, since the induced order is already satisfied.

\paragraph{A2 totality and determinism.}
With 4-connectedness and $\mathrm{topleft}$ defined as the lexicographic minimum cell, two distinct components cannot share the same tuple $(\mathrm{area},\mathrm{topleft}_r,\mathrm{topleft}_c)$; thus the order is total and deterministic.

\paragraph{Compositional invariance and idempotence.}
$C_2(C_1(\pi\!\cdot\!x))=C_2(C_1(x))$ for any palette permutation $\pi$, and $C_2(C_2(\cdot))=C_2(\cdot)$.

\paragraph{Gauge correctness.}
The palette map in $C_1$ and the component-order permutation in $C_2$ are bijections; applying their inverses transfers predictions back to the original instance without loss.

\paragraph{Recolor commutes with palette permutations.}
For any palette permutation $P$, \(\;P(\mathrm{recolor}(x,k))=\mathrm{recolor}(P(x),P(k))\). This enables search in the abstract space and faithful transfer via gauges.

\section{Interpretation}

\begin{itemize}
\item \textbf{A1 (palette canonicalization)} quotients out color symmetry so rules like ``least-frequent color'' become stable; however, it leaves \textbf{object enumeration} ambiguous, hence many decoy selectors and high try counts.
\item \textbf{A2 on top of A1} quotients out object-enumeration symmetry so only the semantically distinct index-based programs remain. Because the DSL is tiny after A1→A2, \textbf{every remaining program is correct} on the studied task, and time-to-solution is near zero.
\end{itemize}

\section{Why A2 is needed (and helpful)}

Ties in geometry (equal-area components, nearby positions) are common in ARC. Without a canonical enumeration, selectors like ``smallest,'' ``top-most,'' or ``first component'' splinter into many arbitrarily-ordered variants. A2 \textbf{chooses one consistent ordering}, eliminating these spurious degrees of freedom and making index-based rules stable across pairs.

\section{Limitations \& Extensions}

\begin{itemize}
\item Our DSL is intentionally tiny; we focused on the symmetry quotient effects, not on broad coverage of ARC.
\item A1's ordering rule (frequency → first occurrence) is one of many possible canonicalizations; other tasks may require different tie-breaks.
\item The mapping-existence step is specialized to \textbf{select×color×recolor}. Richer action families (e.g., geometric rewrites) would need their own existence checks and gauges.
\item Extensions: add shape-level canonicalizations (e.g., rotation/flip quotient), object-relation canonicalizations, and richer color policies while preserving the \textbf{validate→exist→search} pipeline.
\end{itemize}

\section{Reproducibility (runnable artifacts)}

\begin{itemize}
\item \textbf{Script:} \code{arc\_abstraction\_dsl\_2.py}
\item \textbf{Outputs:} \code{challenging\_metrics.txt}, \code{challenging\_metrics.json}
\end{itemize}

Run with \code{python3 arc\_abstraction\_dsl\_2.py}. The script prints a summary (``Challenging Single-Dataset Metrics'') and writes both artifacts in the working directory. The ``Local-run results'' above are taken from your updated run and reflected here.

\section{Takeaways}

Abstractions as \textbf{\code{G + invariant}}, composed as \textbf{A1→A2}, turn a symmetry-riddled search into an almost trivial one for the studied ARC family. The composition removes palette and enumeration symmetries, yields a \textbf{two-program} search space in which \textbf{both} programs are valid, and delivers \textbf{×100+} speedups---all with simple, transparent rules.

\section*{Appendix: Glossary of terms}

\begin{itemize}
\item \textbf{ARC:} Abstraction and Reasoning Corpus; small integer-grid puzzles.
\item \textbf{Symmetry quotient:} Identifying states/programs that differ only by a symmetry (palette permutation, object ordering), keeping a single canonical representative.
\item \textbf{Invariant:} A condition that must hold after normalization (e.g., background \code{0} preserved).
\item \textbf{Gauge:} The bookkeeping needed to transfer an abstract action back to the original instance (palette map, canonical order list).
\item \textbf{Selector:} A rule that names a component (e.g., \code{index0}, \code{smallest}).
\item \textbf{Color rule:} A rule that names a palette color (e.g., \code{least\_frequent}).
\item \textbf{Recolor:} Action that applies the chosen color to the selected component.
\end{itemize}

\end{document}
